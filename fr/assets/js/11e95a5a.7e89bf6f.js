(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7767],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return p},kt:function(){return d}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=r.createContext({}),l=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=l(n),d=a,y=m["".concat(c,".").concat(d)]||m[d]||u[d]||o;return n?r.createElement(y,i(i({ref:t},p),{},{components:n})):r.createElement(y,i({ref:t},p))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=m;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var l=2;l<o;l++)i[l]=n[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},7409:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return p},default:function(){return m}});var r=n(2122),a=n(9756),o=(n(7294),n(3905)),i=["components"],s={sidebar_position:4},c="Entry points",l={unversionedId:"smart-contracts/components/entry-points",id:"smart-contracts/components/entry-points",isDocsHomePage:!1,title:"Entry points",description:"Entry points, or handlers are where messages or queries are handled by the contract.",source:"@site/docs/04-smart-contracts/02-components/04-entry-points.md",sourceDirName:"04-smart-contracts/02-components",slug:"/smart-contracts/components/entry-points",permalink:"/fr/docs/1.0/smart-contracts/components/entry-points",editUrl:"https://github.com/InterWasm/docs/edit/main/docs/04-smart-contracts/02-components/04-entry-points.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"docsSidebar",previous:{title:"Complex State and Maps",permalink:"/fr/docs/1.0/smart-contracts/components/state/complex-state"},next:{title:"Query",permalink:"/fr/docs/1.0/smart-contracts/components/query"}},p=[],u={toc:p};function m(e){var t=e.components,n=(0,a.Z)(e,i);return(0,o.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"entry-points"},"Entry points"),(0,o.kt)("p",null,"Entry points, or ",(0,o.kt)("em",{parentName:"p"},"handlers")," are where messages or queries are handled by the contract."),(0,o.kt)("p",null,"All three of the functions we will be talking about are explicitly flagged as entry points, and excluded from being bundled in the library:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[cfg_attr(not(feature = "library"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    _env: Env,\n    _info: MessageInfo,\n    msg: InstantiateMsg,\n) -> Result<Response, StdError> {\n    // ...etc\n}\n')),(0,o.kt)("p",null,"These handlers are:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Instantiate messages, as defined by the ",(0,o.kt)("inlineCode",{parentName:"li"},"InstantiateMsg")," struct, are handled by ",(0,o.kt)("inlineCode",{parentName:"li"},"instantiate"),"."),(0,o.kt)("li",{parentName:"ol"},"Messages, as defined by the ",(0,o.kt)("inlineCode",{parentName:"li"},"ExecuteMsg")," enum, are handled by the ",(0,o.kt)("inlineCode",{parentName:"li"},"execute")," function, using a pattern-matching ",(0,o.kt)("inlineCode",{parentName:"li"},"match")," statement."),(0,o.kt)("li",{parentName:"ol"},"Queries, as defined by the ",(0,o.kt)("inlineCode",{parentName:"li"},"QueryMsg")," enum, are handled by the ",(0,o.kt)("inlineCode",{parentName:"li"},"query")," function, using a pattern-match.")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"execute")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"query")," must exhaustively match every variant in the enums they handle, while ",(0,o.kt)("inlineCode",{parentName:"p"},"instantiate")," only has to deal with the struct it is passed."),(0,o.kt)("p",null,"Typically, ",(0,o.kt)("inlineCode",{parentName:"p"},"instantiate")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"execute")," have the type ",(0,o.kt)("inlineCode",{parentName:"p"},"Result<Response, ContractError>"),", while ",(0,o.kt)("inlineCode",{parentName:"p"},"query")," has ",(0,o.kt)("inlineCode",{parentName:"p"},"StdResult<Binary>")," due to the underlying Cosmos SDK ",(0,o.kt)("inlineCode",{parentName:"p"},"Querier"),"."))}m.isMDXComponent=!0}}]);